# 第一部分 基础篇

## 第一章：软件交付的问题



一个简单的部署流水线

<img src='./pic/ContinuousDelivery/简单流水线.jpg'/>

### 软件构成部分：可执行的代码、配置信息、运行环境和数据（P10）

- 确保可执行的代码在不同环境下只进行一次编译。
- 对环境的任何修改都应该作为配置信息管理，配置信息的更改都应该被测试。
- 如果运行环境需要修改，则修改后的环境也需要进行测试。环境包括：操作系统配置、应用程序依赖的软件集、网络配置、任何基础设施和外部系统。
- 数据结构发生变化，同样需要经过测试。

### 反馈流程：指完全以自动化的方式尽可能地测试每一次变更（P10）

- 创建可执行代码的流程，且必须奏效。-常用于验证源代码是否符合语法。
- 单元测试：检查应用程序的行为是否与期望相同。
- 质量检测：测试覆盖率以及其他与技术相关的度量项。
- 功能测试验收。检查应用是否满足业务验收条件。
- 性能、有效性、安全性等非功能测试。
- 探索性测试，给客户演示。

### 自动化测试反馈（P11）

 提交commit阶段，测试应有特征。

- 运行速度快。
- 尽可能全面，75%代码库覆盖率。
- 环境中立，相对生产环境简单廉价。
- 如果出现问题，绝不发布。

提交commit阶段之后，测试应有特征。

- 运行速度慢一些，适合并行执行。
- 即使有些测试问题，也可以发布应用程序。
- 运行环境尽可能与生产相同。

### 不同版本、不同环境的配置放在版本控制中

- 开发人员都拥有自己的专属开发环境
- 无论部署在什么目标环境都应采用同一种部署方法
- 开发环境是特例，可以有多变性部署方法

### 软件的交付原则（P19）

- 为软件的发布创建一个可重复且可靠的过程。
- 将几乎所有的事情自动化。
- 将构建、部署、测试和发布软件所需全部纳入版本控制管理之中。
- 版本控制包括：需求文档、测试脚本、自动化测试用例、网络配置脚本、部署脚本、数据库创建、升级、回滚和初始化脚本、库文件、应用程序依赖的软件集、工具链及技术文档等。
- 提前并频繁地做让你感到痛苦的事：比如集成通常是非常痛苦，那应在开始阶段就不断进行集成、测试；如果发布痛苦，每次提交并通过自动化测试后就进行发布。
- 用户故事只有到了已发布才算完成，交付成果属于每个成员，交付前每个成员都为其负责。
- 持续改进，交付过程中，整个团队召开回顾会议，提出改进方向及方法，每个改进点应该同一个人负责跟踪，确保改进被执行，下一次回顾会议，汇报结果。



# 第二章：配置管理

定义：配置管理指一个过程，通过该过程，所有与项目有关的产物，以及它们之间的关系都被唯一定义、修改、存储与检索。

## 使用版本控制（P25）

- 对所有内容进行版本控制（所需的支撑软件配置信息，操作系统配置信息、DNS区域文件和防火墙配置等）

配置管理是持续集成交付过程的基础。

### 依赖管理（P30）

- 外部库文件管理。外部库通常会安装在全局系统路径中，并由包管理系统来管理。
- 组件管理。随着系统不断变大，依赖组件增多时，需要注意将这些构建流水线之间的依赖应该是二进制文件依赖，而不是源文件依赖。

### 软件配置管理（P31）

灵活性：先专注于提供具有高价值且可配置程度低的功能，冒烟测试就是一种缓解配置验证问题的方法。

#### 配置分类

- 推荐应使构建打包生成的包，面向所有环境，并不植入配置信息。

#### 应用程序的配置管理

- 将特定于测试环境或生产环境的实际配置信息存放于与源代码分离的单独代码库，需要注意配置信息的版本，一定要与相应的应用软件的版相匹配。（P34）
- 不要把密码放在版本控制系统中。（P34-tips）
- 获取配置信息：文件系统、从某个中心仓库中获取配置信息。（P35）
- 配置信息：区分应用、版本、环境，都需要满足以下：（P36）
  - 新增一个环境，能为这个配置应用的新环境指定一套新的配置信息。
  - 新建应用程序的一个新版本，确保在部署新版本时，使用新的配置，但是一量需要回滚时，还能够使用旧版本的配置。
  - 将新版本从一个环境移到另一个环境，确保新环境上的新配置里有效。
  - 重定向到一个数据库服务器，只需要简单更改一个配置项
  - 通过虚拟化技术管理环境。
- 一种方法是把预生产环境的配置信息作为默认配置，其它环境通过适当的方式覆盖这些默认值，尽量减少配置项。

#### 跨应用的配置管理（P37-38）

每个应用程序的配置项管理都应该作为项目启动阶段的一个议题，且应维护一份应用程序配置选项索引表，记录配置项的功能，位置及生命周期，如何修改。

- 在应用程序的生命周期中，我们应该在什么时候注入哪类配置信息，要与系统运维和支持团队一同讨论。
- 将应用程序的配置项与源代码保存在一个仓库中，但要把配置项的值保存在别处，另外像用户密码这类敏感信息不应该放在版本控制库中。
- 应该总是通过自动化的过程将配置项从保存配置信息的存储库中取出并设置好，这样就能很容易掌握不同环境中的配置信息了。
- 配置系统应该能依据应用、版本、环境为打包、安装以及部署脚本提供不同的配置值。
- 对每个配置项都应用明确的命名习惯，避免使用难懂的名称。
- 确保配置信息是模块化且封闭的，使得对某处配置项的修改不会影响到那些与其无关的配置项。
- DRY原则。定义好配置中的每个元素，使每个配置元素在整个系统中都是唯一的，其含义绝不与其他元素重叠。
- 最少化，即配置信息应尽可能简单且集中。
- 避免对配置信息的过分设计，应该尽可能简单。
- 确保测试已覆盖到部署或安装时的配置操作。

#### 环境管理（P39）

- 环境中各种各样的操作系统，包括其版本、补丁级别及配置设置。
- 应用程序所依赖的需要安装到每个环境中的软件包，以及这些软件包的具体版本及配置。
- 应用程序正常工作所需的网络拓扑结构。
- 应用程序所依赖的所有外部服务，以及这些服务的版本和配置信息。
- 现有的数据以及其他相关信息。

当评估第三方产品或服务时，应该问自己以下问题：

- 我们可以自行部署它吗？
- 我们能对它的配置做有效的版本控制吗？
- 如何使它适应我们的自动化部署策略？

#### 变更过程管理（P41）

对环境的变更过程进行管理，严格控制生产环境，未经组织内部正式的变更管理过程，任何人不得对其进行修改。
 应该像对待生产环境一样对待测试环境，其配置管理应该与生产环境中的配置管理一样的策略。



# 第三章：持续集成

持续集成要求每当有人提交代码时，就对整个应用进行构建，并对其执行全面的自动化测试集合，一旦出现问题，开发团队应停下手中的工作，修复问题。
 持续集成的目标是：让正在研发的软件一直处于可工作的状态。（P43）

## 实施持续集成的准备三件事（P44）

- 版本控制：与项目相关的所有内容都必须提交到一个版本控制库中（产品代码、测试代码、数据库脚本、构建与部署脚本、以及所有用于创建安装运行和测试该应用的程序的东西）。
- 自动化构建：必须满足人和计算机都能通过命令行自动执行应用的构建、测试以及部署过程。
- 团队共识：持续集成是一种实践，需要团队所有成员都遵循规则。

## 一个基本持续集成系统（P46）

- 第一次在持续集成工具上执行构建时，可能会缺少一些必须的软件及配置，请将所操作的工作记录下来，并放在自己项目的知识共享库中，应花一些时间将应用程序所依赖的所有软件和配置项提交到版本控制系统中，并将重建全新环境的整个活动变成一个自动化的过程。
- 查看一下是否有构建正在运行，如果有，等它运行完。如果它失败了，则与团队其他人一起将它修复，后再提交自己的代码。
- 一量构建完成且测试全部通过，就从版本控制库中将该版本的代码更新到自己的开发环境上。
- 在自己的开发机上执行构建脚本、运行测试，以确保所有代码在本地工作正常。
- 如果本地构建成功，就将代码提交到版本控制库中，然后等待包含本次提交的构建结果。
- 如果构建失败，就停下手中的工作，立即修复这个问题，本地测试通过后，再次提交代码到版本控制库中
- 如果构建成功，开始下一项任务。

## 持续集成的前提条件（P47）

- 频繁提交，开发始终在主干上提交代码。
- 创建全面的自动化测试套件【单元测试（10m），组件测试（较长），验收测试（长）】。

#### 保持较短的构建和测试过程（P48）

理想情况下，提交前的预编译和测试过程与持续集成服务器上的编译和测试过程都应在几分钟内结束，10m是极限，90s内完成最理想。
 如果测试过程太久，则需要找出那些运行较慢的测试，优化它，缩短测试时间。
 测试分为两个阶段：提交阶段、提交后阶段

- 提交阶段：运行所有类别的单元测试，并构建部署的二进制文件。提交前运行一次，通过后再提交到持续集成环境再运行一次。
- 提交后阶段：进行验收测试、集成测试，一旦提交测试通过，立马运行验收测试。如果超过30m，就要考虑采用高性能多进程机器缩短测试时间。

## 使用持续集成软件（P49）

持续集成软件包括两个部分：

- 持续运行的进程，每个一定时间执行一个简单工作流程。

- 提供展示这个流程运行结果的视图，并通知报告 ，拿到生成它的安装文件等。

## 必不可少的实践（P52-57）

- 构建失败之后不要提交新代码。
- 提交前在本地运行所有的提交测试或让持续集成服务器完成此事。
- 等提交测试通过后再继续工作。
- 回家之前，构建必须处于成功状态。
- 时刻准备着回滚到前一个版本。
- 在回滚之前需要规定一个修复时间。
- 不要将失败的测试注释掉。
- 为自己导致的问题负责。
- 测试驱动的开发。

## 推荐的实践（P57）

- 极限编程开发实践。
- 若违背架构原则，就让构建失败。
- 若测试运行变慢，就让测试失败（2s)。
- 若有编译警告或代码风格问题，就让构建失败。

## 小结（P66）

一个好的持续集成系统是基石，在此之上你可以构建更多的基础设置：

- 一个巨大的可视化指示器，用于显示构建系统所收集的信息，以提供高质量的反馈。
- 结果报告系统，以及针对自己测试团队的安装包。
- 为项目经理提供关于应用程序质量的数据的提供程序。
- 使用部署流水线，可以将其延展到生产环境，为测试人员和运维团队提供一键式部署系统。



# 第四章：测试策略的实现

项目在一开始阶段，测试人员就会与开发人员及客户一起写自动化测试。这些测试应该在开发前就写好。

测试象限图

<img src='./pic/ContinuousDelivery/测试象限图.jpg'/>

### 业务导向且支持开发过程的测试（P69）

在开发一个用户故事之前，应写好验收测试，采取完美的自动化形式。
 系统的验收测试应运行在类生产环境（UAT)
 验收测试有价值的特性：

- 它加快了反馈速度。
- 减少了测试人员的工作负荷。
- 让测试人员集中精力做探索性测试和高价值的活动。
- 这些验收测试也是一组回归测试套件。
- 行为驱动开发，可以以这些测试中自动生成需求说明文档。

并不是所有的东西都需要自动化。我们倾向于将自动化验收测试限于完全覆盖Happy Path的行为，并仅覆盖其它一些极其重要的部分。每一种测试都应该覆盖应用程序的80%。

验收测试一般都是端对端测试，但是这样很多时候验收测试的失败并不是因为真正的缺陷，而是因为界面的变更，这将导致增大了验收测试脚本的维护。有两种方法解决这个问题：

- 在测试与用户界面之间增加一个抽象层，以便减少因用户界面变更而导致的问题。

- 通过公共API来运行这些验收测试，用户界面会使用这些公共API来执行真正的操作。


### 技术导向且支持开发过程的测试（P72）

单元测试：不应该访问数据库，不应该使用文件系统，不与外部系统交互。
组件测试：涉及更多的准备工作并执行更多的IO，需要连接数据库，文件系统，与外部系统交互
部署测试：用于检查部署过程是否正确。

### 业务导向且评价项目的测试（P72）

探索性测试，并不只是发现缺陷，它还会致使创建新的自动化集合。
易用性测试，为了验证用户是否能很容易使用该应用软件完成工作。
Beta测试，金丝雀发布，多个版本同时运行在生产环境，收集不同版本的数据，如果分析证明新功能无法带来足够的价值，就删除它。

### 技术导向且评价项目的测试（P73）

验收测试分两类：功能性测试，非功能性测试。

### 测试替身（P74）

- 哑对象：那些被传递但不被真正使用的对象。

- 假对象：可以真正使用的实现，但通常会利用一些捷径。

- 桩：在测试中为每个调用提供一个封装好的响应，它通常不会对测试之外的请求进行响应，只用于测试。

- SPY：一种可记录一些关于它们如何被调用的信息的桩。

- 模拟对象：一种在编程时就设定了它的预期要接收的调用。


### 现实中的情况与应对策略

#### 新项目：一开始就要写自动化验收测试（P75）

- 选择技术平台和测试工具。
- 建立一个简单的自动化构建。
- 制定遵守INVEST原则【独立的，可协商的，有价值的，可估计的，小的，可测试的】用户故事及考虑其验收条件。
- 客户、分析师和测试人员定义验收条件。
- 测试人员与研发人员一起基于验收条件实现验收测试的自动化。
- 开发人员编码来满足验收条件。
- 只要有自动化测试失败，开发人员优先修复问题。

#### 项目进行中（P76）

- 引入自动化测试最好的方式是选择应用程序中那些最常见，最重要且高价值的用例为起点。
- 让测试覆盖的范围稍稍宽于通常的用户故事级别的验收测试。
- 如果发现对同一个功能重复进行了多次的手工测试，就判断该功能是否还会个性。如果不会，就将这个测试自动化，否则，说明这个测试覆盖的功能一直变化，可以与客户和开发确认后，把它从测试集合中先忽略掉，并尽可能详细地写注释。
- 如果时间紧，最好利用各种各样的测试数据来确保一定的覆盖率。

#### 遗留系统（P77）

- 如果没有自动构建流程，最高优先级是创建一个自动构建流程，然后创建更多的自动化功能测试来丰富它。
- 识别系统中高价值的功能，聚焦于系统中高价值的功能。
- 基于高价值功能，创建一套广泛的自动化测试。
- 逐渐为新增功能添加相应的测试。
- 只写那些有价值的自动化测试，如果只是新增功能，而不需要修改提供支撑的框架代码时这部分代码不需要写全面的测试。

#### 集成测试（P78）

集成测试：那些确保系统的每个独立部分都能够正确作用于其依赖的那些服务的测试。
集成测试应该在两种上下文中运行：

- 被测试的应用程序使用其真正依赖的外部系统来运行时，或使用由外部服务供应商所提供的替代系统
- 应用程序运行于你自己创建的一个测试用具之上。
   确保在正式部署生产环境之前，应用程序不要与真实的外部系统进行交互，否则就要想办法告诉外部系统，应用所发送的数据只用于测试。
- 在测试环境中使用“防火墙”，将该应用程序与外部系统隔离开来。
- 在应用程序中用一组配置信息，让其与外部系统的模拟版本交互。
   把关于集成的活动放到发布计划中是非常必要的。与外部系统的集成总是比较复杂，需要花时间并制定计划。每当增加一个外部系统集成点时，项目风险就会增，集成风险。
- 测试服务是否准备好了？它是否能正常运行？
- 外部服务供应商是否有足够的资源与人力来回答我们遇到的问题，修改缺陷，添加我们提出的一些定制功能?
- 我们是否能直接访问真实的生产环境，以便验证外部系统是否满足我们的容量要求或可用性要求？
- 外部服务提供的API是否很容易与我们自己开发应用软件时所采用的技术进行集成，我们团队是否需要某些专业技能才能使用这些API?
- 是否需要编写并维护我们的测试服务？
- 当外部系统的响应与我们所期望的行为不一致时，我们自己的应用程序是否能够正确地处理？
- 还需要构建与维护这个集成层及相关的运行时配置，测试服务与测试策略。

### 流程（P80）

- 找出最高优先级的测试场景。
- 代码让这些验收条件变成可执行的测试。
- 测试人员与研发人员在开发前应尽早一起讨论验收测试。
- 增加更多的数据来提高测试的覆盖率。

### 管理待修复的缺陷列表（P81）

- 将待修复缺陷列表可视化。
- 一种零缺陷，关注缺陷问题，并修复。
- 像对待功能一样对待缺陷，将功能与缺陷一起做优先级排序，让开发按优先级进行开发。



# 第二部分 部署流水线

# 第五章：部署流水线解析

## 什么是部署流水线（P85）

部署流水线是指软件从版本控制到用户手中这一过程的自动化表现形式。

价值流图

<img src='./pic/ContinuousDelivery/价值流图.jpg'/>

代码变更流水线

<img src='./pic/ContinuousDelivery/代码变更流水线.jpg'/>

## 部署流水线的相关实践（P91）

#### 只生成一次二进制包

- 对于不需要编译的语言，二制包指的是所有源文件的集合。这些二进制包应保存在文件系统的某个位置，让流水线后续阶段能够轻松访问到，但不要放在版本控制库中。二进制包应与环境无关。

#### 对不同环境采用同一部署方式（P93）

- 使用属性文件保存配置信息。比如分别为每个环境保存一个属性文件，并将其放在版本控制库中，部署时，通过本地服务器的主机名来查找到正确的配置，如果环境中有多台服务器，可以将环境变量提供给部署脚本。
- 将配置放在一个目录服务中（LDAP或ActiveDiretory）或数据库中。

#### 对部署进行冒烟测试（P94）

当应用程序部署时，应用一个自动化脚本做下冒烟测试。这个测试的流程是：

- 启动用户程序。
- 检查主页面。
- 检查应用程序所依赖的服务，比如数据库，消息队列等。

#### 向生产环境的副本中部署

 如果预算充足，可以建立与生产环境一样的环境。

#### 每次变更都要立即在流水线中传递

 对于一些特殊情况，验收测试是比较耗时的，版本在验收测试时可能会产生冲突，这时可以在单元测试结束时，将最近还没构建的所有变更全部拿来进行构建。

#### 只要有环节失败，就停止整个流水线

## 提交阶段（P97）

- 编译代码。
- 运行一套提交测试（单元测试，容易失败的特定测试）。
- 为后续阶段创建二进制包。
- 执行代码分析检查代码的健康状况。
- 为后续阶段准备工作，比如准备后续测试所用的数据库。

## 自动化验收测试之门（P99）

- 每次提交后，应立即运行提交测试，提交阶段完成后，立即做验收测试，简单的验收测试为：运行代码，查看主页。
- 尽管验收测试非常有价值，但它们的创建与维护成本也非常高，所以牢记不要把所有验收测试条件盲目的自动化。

## 后续的测试阶段（P102）

部署流水线应支持测试人员根据自己的需求将任意一个版本部署到自己的测试环境。

- 手工测试
- 非功能测试

## 发布准备（P104）

### 把发布环节视为部署流水线的一个自然结果

- 让参与项目交付过程的人共同创建维护一个发布计划。
- 通过尽可能多的自动化过程最小化人的错误发生的可能性。
- 在类生产环境中经常做发布流程演练。
- 如果事情并没有按计划执行，要有撤销本次发布的能力。
- 作为升级和撤销过程的一部分，制定配置迁移和数据迁移策略。

### 自动部署与发布（P105）

- 在具有代表性环境上执行自动化验收测试套件。
- 对生产环境的任何修改都应该通过自动化过程完成（程序的部署，配置，软件栈，网络拓扑，状态的所有修改）。
- 管理生产环境的流程，也应用于测试环境。
- 使用虚拟化技术，最佳配置管理降低成本。

### 变更的撤销策略（P106）

- 让旧版本仍旧处于可用状态，保持一段时间。
- 从头部署旧版本。

## 实现一个部署流水线（P107）

- 对价值流建模，创建一个可工作的简单框架。

- 将构建和部署流程自动化。

- 将单元测试和代码分析自动化。

- 将验收测试自动化。

- 将发布自动化。

  ######  注意以下几点：（P110）

- 增量实现整个流水线，如果有手工操作部分，记录开始结束时间，想办法把它自动化。

- 部署流水线是构建、部署、测试和发布整个流程中有效，也是最重要的统计数据来源。

- 不断改进部署流水线。

## 度量（P111）

最重要的全局度量指标是流水线周期时间。用约束理论来对流水线进行优化：

- 识别系统中的约束。
- 确保最大限度地提高流程中这部分的产出。
- 根据这一约束调整其他环节的产出。
- 为约束环节扩容，增加资源。
- 理顺约束环节，找到下一个约束点。



# 第六章：构建与部署的脚本化

## 构建工具概览

一个简单的构建依赖关系图

<img src='./pic/ContinuousDelivery/一个简单的构建依赖关系图.jpg'/>

构建工具：Make、Ant、NAnt与MSBuild、Maven、Rake、Buildr、Psake

## 构建部署脚本化的原则与实践（P122）

- 为部署流水线的每个阶段创建脚本。
- 使用恰当的技术部署应用程序。
- 使用同样的脚本向所有环境部署。
- 使用操作系统自带的包管理工具。
- 确保部署流程是幂等的。
- 部署系统的增量式演进。

## 部署脚本化

### 多层的部署和测试（P131）

软件部署中的层级视图

<img src='./pic/ContinuousDelivery/软件部署中的层级视图.jpg'/>

### 测试环境配置（P131）

 部署前对基础设施做标准冒烟测试，如果发现问题，就让环境配置流程快速失败，并给出测试结果。

- 确认能从数据库中拿到一条记录。
- 确认能连上网站。
- 断言消息代理中的已注册的消息集合是正确的。
- 透过防火墙发送ping，证明线路通畅。

## 小贴士（P132）

- 总是使用相对路径。

- 消除手工步骤。

- 从二进制包到版本控制库的内建可追溯性。

  二进制包记录版本信息，如Java应用可以在MANIFEST中包含元数据，另外可以将构建流程生成的每个二进制包的MD5值及名字和版本标识符一起放在数据库中。

- 不要把二进制包作为构建的一部分放到版本控制库中。

- "test"不应该让构建失败。
  在构建时如果有一个test任务失败，应该设置一个标记，继续构建，当生成更多的结果报告或者更完整的测试集后再令构建失败。

- 用集成冒烟测试来限制应用程序。

- .NET项目中确保bin和obj这两个目录被完全删除。



# 第七章：提交阶段

理想情况下，提交阶段的运行应该少于5分钟，一定不要超过10分钟。

提交阶段是开始构建部署流水线的起点。

提交阶段的首要目标是创建可部署的产物。

## 提交阶段的原则与实践（P138）

- 提供快速有用的反馈。
- 何时令提交阶段失败。
  - 编译错误。
  - 测试失败（包括单元覆盖率低于60%）。
- 精心对待提交阶段。
  - 提交阶段中有构建用的脚本和运行单元测试、静态分析等脚本。
  - 随着项目的进行，不断改进提交阶段的脚本的质量、设计和性能。
  - 确保将脚本做成模块化，将那些经常使用且很少变化的常见任务与需要修改的任务分开。
  - 将部署流水线中不同阶段所用的代码分别写在不同脚本中。
  - 不要写出与具体环境相关的脚本，即要把具体环境配置与构建脚本分离。
- 让开发人员也拥有所有权。
   如果必要的话，即使是很普通的变更也都应该由开发人员和运维人员来执行。
- 在超大项目团队中指定一个构建负责人。
  - 监督和指导对构建的维护。
  - 鼓励和加强构建纪律。
  - 在团队开始接触持续集成时，构建纪律还没建立起来时，提醒作用。
  - 团队成员轮流当，比如每星期轮换一次。

## 提交阶段结果（P142）

提交阶段的输入是源代码，输出是二进制包和报告（测试结果和代码分析报告）。

### 制品库（P143）

- 制品库仅保存某些版本，而不是全部。如果在部署流水线某个阶段失败，就可以删除该版本。
- 制品库中的二进制包能够追溯到具体的代码版本控制库中的版本。
- 良好的配置管理策略，二进制文件的构建过程应该是可重复的。

## 提交测试套件的原则与实践(P144）

- 提交阶段，测试绝大部分应由单元测试组成。
- 设计 能够快速运行的提交测试策略。
- 运行的单元测试不应该与文件系统、数据库、库文件、框架或外部系统等交互。

### 提交测试实践（P144-150）

- 避免用户界面。
- 使用依赖注入。
- 避免使用数据库。
  单元测试不应该依赖于数据库，需要把测试的代码与其存储分离开来。这就要求代码实现良好的分层，也需要使用依赖注入。如果实在无法做到，使用内存数据库。
- 避免异步。
- 使用测试替身。
   模拟技术工具集：Mockito、Rhino、EasyMock、JMock、NMock、Mocha等。
- 最少化测试中的状态。
   降低要构造的测试环境的复杂性。
- 时间的伪装。
  对于那些需要确保一定延时或者定时的行为，需要对其中的时间系统进行控制。作者团队的经验是，只要代码中需要使用时间，就会抽象到对系统时间服务的请求，而不是直接在业务逻辑中调用它们。
- 蛮力（测试阶段运行应该少于5分钟）。
  - 将提交测试分成多个套件，在多台机器上并行执行（构建网格）。
  
  - 作为构建优化过程的一部分，将那些运行时间长，且不经常失败的测试放在验收测试阶段。
  
    

# 第八章：自动化验收测试

验收测试通常是在每一个通过提交测试的软件版本上执行的。

验收测试阶段图

<img src='./pic/ContinuousDelivery/验收测试阶段图.jpg'/>

验收测试的目的：对于一个单独的验收测试，它的目的是验证一个用户故事或需求的验收条件是否被满足。如功能验收条件和非功能验收条件。（P154）

验收测试与单元测试的区别：验收测试是针对业务的，单元测试是面向开发的。

## 实现验收测试（P167）

- 让测试对复杂状态的依赖最小。
- 不要使用生产数据的备份作为验收测试的测试数据，要维护一个受控的数据最小集。
- 满足原子性，测试的执行顺序无关紧要，可以并行执行，他创建它需要的一切，并在运行后清理干净。
- 自动化验收测试不应该运行在包含所有外部系统集成点的环境中，应该为自动验收测试提供一个受控环境，并且被测系统应该能在这个环境下运行。使用替身对象取代外部系统，可以使系统与外部系统耦合最小。

## 验收测试阶段（P174）

把验收测试套件作为部署流水线的一个组成部分来运行。提交测试一旦成功，就应该开始在通过提交测试的版本上运行验收测试套件。

- 验收测试失败的版本不能用于部署。
- 确保验收测试一直处于通过状态。

## 验收测试的性能（P178）

验收测试没有把它放在提交测试阶段，主要是因为验收测试运行时间太长。但是我们认为自动化验收测试的全面性比测试在10分钟内运行完成更重要。然而一旦开始实现部署流水线，快速失败体系和迅速反馈环将更快地帮助发现问题，一般验收测试花费几个小时完成也是可以接受的。但是仍然有办法来提高验收测试的效率。

- 重构通用任务
- 共享昂贵资源
- 并行测试
- 使用计算网格（如：Selenium Grid、 Zalenium）



# 第九章：非功能需求的测试

### 性能、吞吐量、容量概念(P183)

性能：对处理单一事务所花时间的一种度量，既可以单独衡量，也可以在一定的负载下衡量。
吞吐量：系统在一定时间内处理事务的数量，通常它受限于系统中的某个瓶颈。
容量：一定的负载下，当每个单独请求的响应时间维持在可接受范围内时，系统所能承担的最大吞吐量。
非功能性：有效性、容量、安全性、可维护性等。

### 非功能需求管理(P184)

将非功能需求与功能需求一样对待。

- 创建一些具体任务来管理非功能需求。
- 有必要的话，向功能需求中加入非功能需求的验收条件。

### 如何为容量编程

1. 为何要做容量测试(P186)
    高德纳著名格言：
    **在97%的时间里，我们都应该忘记那种小的效率提升：过早优化是所有罪恶之根。然而，我们也不能让另外非常关键的3%的机会与我们擦肩而过。一个优秀程序员不会因为这个原则而对其置之不理，他们非常聪明，只会在识别出那段关键代码后，才会非常细心地去查看。**
    在找到解决方案之前，必须先找出问题的根源。容量测试会告诉我们是否存在问题，以便我们可以修复它。不要枉自猜测，而要先进行度量。
2. 解决容量问题
   现代软件系统中，最昂贵的是网络通信或磁盘存储，在性能和应用程序的稳定性方面，跨进程或网络边界的通信是昂贵的，所以这类通信应该尽量最小化。
   让业务干系人决定系统的容量特性极其重要，以免方案过度设计 。
   为解决容量问题，可采取的策略(P187)：

- 为应用程序决定一种架构。通常要特别注意进程、网络边界和I/O。
- 了解并使用正确的模式，避免使用那些影响系统容量和稳定性的反模式。
- 确保团队在已经明确的应用架构下进行开发，不要为容量做无谓的优化。在没有明确测试结果表明有容量问题时，坚决不能在代码可读性上让步。
- 注意在数据结构和算法方面的选择，确保它们的属性与应用程序相吻合。
- 处理线程时要特别注意。
- 创建一些自动化测试来断言所期望的容量级别。当这些测试失败时，用它们作为向导来修复这些问题。
- 使用调测工具主要关注测试中发现的问题，并修复它。
- 只要有可能，就使用真实的容量数据来做度量。

### 容量度量(P188)

- 扩展性测试：随着服务器数、服务等的增加，单个请求的响应时间和并发用户数的支持会如何变化。
- 持久性测试：长时间运行应用程序，是否有性能上的变化。
- 吞吐量测试：系统每秒能处理多少事务、消息或页面点击。
- 负载测试：当系统负载增加到类似生产环境大小时，系统的容量如何。

容量度量测试遵行有两种策略：

- 把目标设定为得到稳定、可重现的结果。专为容量测试准备一个环境。
- 一旦某个测试通过了最低验收标准，就把验收标准提高一点，调整该测试的成功门槛。
- 每个测试都必须体现一个具体的场景，并且只有达到某个标准门槛时，才能认为该测试通过。

### 容量测试环境（P191）

- 容量测试环境与生产环境一致。
- 如果无法提供与生产环境相似的环境，可以把容量测试作为金丝雀发布策略的一部分来执行。更频繁的发布可以减小影响应用程序容量的修改所带来的风险。
- 容量测试环境尽可能与生产环境相似。这样虽然无法满足容量目标，但是可以把那些严重的问题突显出来
- 不要依据硬件的某种特定参数对程序的扩展性作出线性推论。
- 复制应用程序一小部分的服务器进行容量测试，是一个既可以降低环境成本又能提供适当准确度量的策略。

### 自动化容量测试（P194）

- 一般我们都是把容量测试当作一项独立的工作，但是当容量非常重要时，那么就暂且忽视这些时间成本 。这时需要在部署流水线中加入容量测试阶段。
- 创建一个自动化容量测试套件，且每次对应用程序进行修改后，通过了提交测试和验收测试就应该执行容量测试。
- 容量测试要达到如下6个目标。

1. 测试具体的现实场景。
2. 预先设定成功的门槛。
3. 尽可能让测试运行时间短一些。
4. 在变更面前要更健壮一些。
5. 组合成大规模的复杂场景。
6. 可重复的，并且既能串行执行，也能并行执行。

### 容量测试系统的附加价值

容量测试系统是一个试验场所，可以根据需要有效地控制时间，设计和执行所有的试验场景来帮助诊断问题、预测问题并找到触发问题办法。（P201）

- 重现生产环境中发现的复杂缺陷。

- 探测并调试内存泄漏。

- 持久性测试。

- 评估垃圾回收的影响。

- 垃圾回收的调优。

- 应用程序参数的调优。

- 第三方应用程序配置的调优，如操作系统。

- 模拟非正常、最糟糕的情况。

- 评估一些复杂问题的不同解决方案。

- 模拟集成失败的情况。

- 度量应用程序在不同硬件配置下的可扩展性。

- 与外部系统进行交互的负载测试。

- 复杂部署的回滚演练。

- 有选择地使系统部分或全部瘫痪，从而评估服务优雅降级。

- 在短期可用的生产硬件上执行真实世界的容量基准，以便计算出长期且低配的容量测试环境中更准确的扩展因素。

  

# 第十章：应用程序的部署与发布

发布到生产环境和部署到测试环境的差异应该被封装在一组配置文件中，遵循一样的部署过程。启动自动部署系统，将要部署的软件版本与环境名称告诉它，点击开始，后缀部署与发布使用相同的流程。
我们需要有一个列表，其中包含能够部署到每个环境的所有构建，并且只要通过点击就可以选择一个软件版本向某个环境进行自动部署。同时这种方式是对环境修改的唯一途径（包括对操作系统和第三方软件配置的修改）。

## 创建发布策略（P204）

- 每个环境的部署由发布由谁负责。
- 创建一个资产和配置管理策略。
- 部署时所用的技术的描述。运维团队与开发团队应对其达成共识。
- 实现部署流水线的计划。
- 枚举所有的环境，包括用于验收测试、容量测试、集成测试、用户验收测试的环境，以及每个构建在这些环境中的移动过程。
- 描述在测试和生产环境中部署时应该遵循的流程，比如一个变更申请，及申请授权等。
- 对应用程序的监控需求，包括用于通知运维团队关于应用程序相关状态的API和服务。
- 讨论部署时和运行时的配置方法如何管理，以及它们与自动化部署流程是如何关联在一起的。
- 描述应用程序如何与所有外部系统集成。
- 如何记录日志详情，以便运维人员能够确定应用程序的状态，识别出错原因。
- 制定灾难恢复计划，以便在灾难发生后，恢复应用程序的状态。
- 对软件的服务级别达成一致。
- 生产环境的数量大小 及容量计划：应用程序会创建多少数据，需要多少个日志文件或数据库，需要多少带宽或磁盘空间，用户对响应延迟的容忍度是什么？
- 制定一个归档策略，以便不必为了审计或技术支持而保留生产数据。
- 如何对生产环境进行首次部署。
- 如何修复生产环境中出现的缺陷，并为其打补丁。
- 如何升级生产环境中的应用程序以及迁移数据。
- 如何做应用程序生产服务与技术支持。

随着项目的进行，这个策略文档也会改变。

## 应用程序的部署与晋级

每次部署时都使用同样的方法，使用相同的流程向每个环境部署，包括生产环境。在首次向测试环境部署时就应该使用自动化部署。

#### 首次部署（P206）

在第一个迭代里，选择一至两个具有高优先级但非常简单的用户故事或需求，让部署流水线的前几个阶段可以运行，且能够部署并展示一些成果。把它看作实现部署流水线的“抽水泵”
 这个启动迭代结束后，应该已经完成了以下内容：

- 部署流水线线的提交阶段。
- 一个用于部署的类生产环境。
- 通过一个自动化过程获取在提交阶段中生成的二进制包，并将其部署到这个类生产环境（UAT）中。
- 一个简单的冒烟测试，用于验证本次部署的正确性。

#### 对发布过程进行建模并让构建晋级（P207）

在构建中重点注意以下内容：

- 为了达到发布质量，一个构建版本要通过哪些测试阶段。
- 每个阶段需要设置怎样的晋级门槛或者需要怎样的签字许可。
- 对每个晋级门槛来说，谁有权批准让该构建通过该阶段。

测试与发布流程图

<img src='./pic/ContinuousDelivery/测试与发布流程.jpg'/>

#### 配置的晋级

除了二进制需要晋级，环境与应用程序的配置信息也需要晋级。但是并不是所有的配置都需要晋级，这就需要对配置信息进行晋级管理。（P209）

- 用冒烟测试来验证配置信息的正确性。
- 对于中间件的配置，利用像Nagios这样工具来监控这些设置。
- 写一些对基础设置的测试，用于检查关键设置，并将其返回给监控软件。

#### 联合环境

SIT环境中更多的工作是部署每个应用程序的新版本，直到所有应用程序可以互相联通。

#### 部署到试运行环境

项目开始时就需要计划以下事情（P210）：

- 确保生产环境、容量测试环境和试运行环境已准备好。
- 准备好一个自动化过程，对环境进行配置，包括网络配置、外部服务和基础设置。
- 确保部署流程是经过充分冒烟测试的。
- 度量应用程序的“预热”时长。如果应用程序使用了缓存，这一点就尤其重要，将它也纳入到部署计划中。
- 与外部系统进行测试集成。
- 如果可能，发布之前就把应用程序放在生产环境上部署。**蓝绿部署**
- 如果可能，把应用程序发布给所有人之前，将它发布给一小部分用户群。**金丝雀发布**
- 将每次已通过验收测试的变更版本部署在试运行环境中。

## 部署回滚和零停机发布

制定回滚计划时，需要遵循两个原则（P211）：

- 发布前，确保生产系统的状态（数据库和保存在文件系统中的状态）已备份。
- 每次发布之前都练习一下回滚计划，包括从备份中恢复或把数据库备份迁移回来。

#### 通过重新部署原有的正常版本来进行回滚

优点：可预知时间内恢复，且风险较低；部署操作经过运行，而回滚频率低，所以回滚脚本更不稳定。
缺点：部署需要时间，业务有中断；覆盖部署，难以查找问题原因；新版本运行时产生的数据丢失。

#### 零停机发布

将用户从一个版本几乎瞬间转移到另一个版本，如果出问题，可以瞬间将用户转到碑的版本上。不同版本应用独立部署。（P212）

#### 蓝绿部署

保留两个相同的生产环境版本，“蓝环境”、“绿环境”。
将新版本部署在“蓝环境”下，在蓝环境下测试完成后，将路由配置到蓝环境。如果出现问题，把路由器切回到绿环境上即可，此时蓝环境用于查找问题。

##### 蓝绿部署要小心管理数据库。解决办法如下（P213）：

在切换之前暂时将应用程序变成只读状态一小段时间，将绿数据库复制一份，并恢复到蓝数据库中，执行迁移操作，再将用户切换到蓝系统。如果一切正常，再把应用程序切换到读写方式，如果出现问题，只要把它切回绿数据库就可以了。
如果问题出现时，应用程序中已经写入了一些数据到蓝系统，那么切回去之前需要将新记录迁回到绿数据库中。
还可以找个办法让应用程序的新版本把数据库事务同时发向新旧两个数据库。

如果只有一个生产环境，也可以使用蓝录部署。让应用程序两个副本一起运行在同一个环境中。

#### 金丝雀发布

金丝雀发布：把应用程序的某个新版本部署到生产环境中的部署服务器中，从而快速得到反馈。

1. 部署新版本到一部分服务器上，对新版本上做冒烟测试，容量测试。
2. 选择一部分用户，把他们引到新版本上。
3. 还可以部署多个版本，将不同组用户引导到不同版本上。

优点：

- 非常容易回滚，只要不把用户引到有问题的版本。
- 将用记引致新旧版本，从而作A/B测试。
- 可以通过逐渐增加负载，慢慢地把用户引到新版本，检验应用程序是否满足容量需求。

## 紧急修复

牢记：任何情况下，都不能破坏流程。紧急修复版本也需要走构建、部署、测试和发布流程。
让每个紧急修复都走完标准的部署流水线。
紧急修复的另一个做法是回滚到旧的好版本上。
处理生产环境的缺陷时应用考虑以下因素（P216）：

- 别加班到深夜来做，应该与别人一起结对做。
- 确保有一个已经测试过的紧急修复流程。
- 对于应用程序的变更，避免绕过标准的流程，除非在极端情况下。
- 确保在试运行环境上对紧急修复版本做过测试。
- 有时候回滚比部署新的修复版本更划算。

## 持续部署

使用部署流水线、让部署到生产也自动化。如果某次提交的代码通过了所有的自动化测试，就直接部署到生产环境中。
持续部署可以与金丝雀发布结合，先通过自动过程发布给一小部分用户，如果没有问题，就发布给所有用户。

## 小贴士和窍门

- 真正执行部署操作的人应该参与部署过程的创建。
- 记录部署活动。
- 不要删除旧文件，而是移动到别的位置。
- 部署是整个团队的责任。
- 服务器应用程序不应该有GUI。
- 为新部署留预热期。
- 快速失败。
- 不要直接对生产环境进行修改。



# 第十一章：基础设施和环境管理

基础设施与环境管理的目标是让所有测试环境（包括持续集成环境）都要与生产环境相似，特别是它们的管理方式。
**环境**是指应用程序运行所需的所有资源和它们的配置信息。有如下这些属性：组成运行环境的服务器的硬件配置信息：如CPU类型和数量、内存大小、硬盘和网卡等；应用程序运行所需要的操作系统和中间件：如消息队列、应用服务器、web服务器及数据库服务器等的配置信息。
**基础设施**代表了所在组织中的所有环境以及支持运行的所有服务，如DNS服务器、防火墙、路由器、版本控制库、存储、监控、邮件服务、日志服务等。
**准备部署环境及管理它，要基于以下原理**，用一个整体方法来管理所有基础设施（P224）：

- 使用保存于版本控制库中的配置信息来指定基础设施所处的状态。
- 基础设施应该具有自治特性，即它应该自动地将自己设定为所需状态。
- 通过测试设备和监控手段，应该时时都能掌握基础设施的实时状况。
- 基础设施还应该具有非常容易重新搭建的特性。

为了减少在类生产环境中的部署风险，需要精心管理以下内容:

- 操作系统及其配置信息，包括各个环境。
- 中间件软件栈及其配置信息，包括应用服务器、消息系统和数据库。
- 基础设施软件，如版本控制库、目录服务器及监控。
- 外部集成点，比如外部系统和服务。
- 网络基础设施，包括路由器、防火墙、交换机、DNS和DHCP等
- 应用程序开发团队与运维团队间的关系。

## 理解运维团队的需要

开发团队往往需要尽可能快地交付软件，而运维团队的目标是稳定性。所有人的共识是：让发布有价值的软件成为一件低风险的事情。做这件事的最好方法是频繁发布，每次发布的变更很小。
运维团队使用熟悉的技术，在各个环境统一部署技术栈。开发人员是最开始部署环境的，所以一开始运维团队也需要在最开始写脚本的时候就加入其中。
对应用程序配置、中间件配置、操作系统配置、数据库配置等都需要进行统一管理。将它们像源代码一样加入版本控制库中，同时它们的配置也是部署流水线的一部分。

## 基础设施的建模和管理

如果项目处于开始阶段，这是制定基础设施配置管理策略的好时机。如果是一个遗留系统，并且没有好的控制规范的话，就要找出让它处于受控状态的方法。

**基础设施的访问控制**（P230）

- 在没有批准的情况下，不允许他人修改基础设施。
- 制定一个对基础设施进行变更的自动化过程。
- 对基础设施进行监控，一旦发生问题，迟早发现。

**对基础设施的修改**是一个严肃的问题，在个问题上对测试环境与对生产环境同等重要。如果无法通过一个自动化过程从头重新创建基础设施的话，首先要实现访问控制，没有审批，不得对基础设施做任何修改；接下来在不关闭访问控制的情况下，创建自动化过程来管理基础设施。当然对测试环境的变更审核可以比生产环境的变更审核更容易些。

- 无论做哪类变更，如防火墙等都要走同样的变更管理流程。
- 流程使用一个所有人都需要登录的工单系统来管理。
- 变更应该有详细的记录。
- 能够看到每个环境进行的变更历史，包括部署活动。
- 生产环境变更前，必须先在类生产环境中测试通过，自动化测试也已经运行完成。
- 对每次修改都应该做版本控制，并通过自动化流程对基础设施进行变更。
- 需要有一个测试来验证变更是否成功。

## 服务器的准备及其配置的管理

服务器可以使用PXE来做自动化的远程安装，或者使用虚拟化技术。同时服务器的配置需要添加到版本控制库中进行统一管理。一旦安装好操作系统后，就必须保证任何配置的修改都是以受控方式进行。除了运维团队外，任何人不能登录到服务器上，同时所有的变更都使用自动化系统来执行。

## 中间件的配置管理

中间件如果是系统标准安装的部分，直接使用配置管理工具进行部署；而如果不是系统标准安装的部分，可以将中间件打包，并将它放在包管理服务器上，然后使用同样的方式对其进行管理；最后对于没有考虑脚本化或者后台安装的产品，需要对其进行改造，并将配置相关的文件进行版本控制。

## 基础设施服务的管理

经常会出现已经成功完成部署流水线并在生产环境中运行的软件因为基础设施问题而不同正常工作。如DNS服务问题等。这种问题一般会比较难以诊断。有以下几个建议（P244）：

- 对网络基础设施的每个部分都应该进行版本控制，使用Ansible类似的工具将配置文件从版本控制库中取出放在系统中运行，实现自动化。
- 安装一个好用的网络监控系统。
- 应用程序中对网络连接出现问题时，日志记录。
- 确保冒烟测试在部署时检查所有的连接。
- 确保集成测试环境的网络拓扑尽可能与生产相似。
- 出现问题时，可以使用tcpdump和wireshark进行排查。

## 多宿主系统

生产系统中一个重要的增强部分是不同类型的流量使用多个隔离网络，并与多宿主服务器结合使用。多宿主服务器多个网络，一个用于运行备份，一个用于服务器的监控与管理，一个用做服务器间数据传输。（P244）

## 基础设施和应用程序的监控

创建监控策略时，需要考虑以下四点（P257）：

- 对应用程序和基础设施进行监测，以便可以收集必要的数据。
- 存储数据，以便拿来分析。
- 创建一个信息Dashboard，将数据聚合在一起图表的形式展现出来。
- 建立通知机制，便于及时关注关心的事件。

监控数据类型：

- 硬件，通过带外监控服务器的电压、温度、系统风扇速度、peripheral health等。
- 构成基础设施的那些服务器上的操作系统，比如内存使用、CPU使用情况、交换分区、磁盘、IO、带宽等使用情况。
- 中间件，如内存、数据库连接池、线程池、连接数、响应时间等。
- 应用程序，设计一些数据监控的hook，比如业务交易数量、价格、转换率等。



# 第十二章：数据管理

应用程序可以通过删除前一个版本，使用新版本替换旧版本的方式部署，但是大多数系统，数据无法使用这种方式进行变更，一旦某个系统发布到了生产环境中，关联的数据将不断增加。数据往往是系统中最有价值的部分。当我们需要对数据系统进行结构修改或者内容修改时，就需要相关的策略。
对数据的修改是不可避免的，关键在于将数据迁移过程自动化。目前有一些工具对数据迁移提供了较多支持，它们还允许对数据库进行版本化管理。
另一个重要部分是测试数据的管理。（P263）

## 数据库脚本化

任何数据库的修改都应该通过自动化过程来管理。包括`数据库的初始化`，`数据库所有的迁移`都需要脚本化，并将脚本提交到版本控制库中。
 几乎所有的数据管理系统都支持通过自动化脚本进行数据存储的初始化工作。

- 清除原有的数据库。
- 创建数据库结构、数据弯路实例以及模式等。
- 向数据库加载数据。

在大多数据项目中，数据库的使用要复杂得多。（P265）

## 增量式修改

绝大多数据系统，对数据库更新时，要保留它们的数据。由于在部署时需要保留数据库中的已有数据，所以需要有回滚策略，以便部署失败时使用。这就需要对数据库进行版本控制。（P265）

- 在数据库中创建一个数据，用来保存版本号。
- 每次数据库进行修改时，需要创建两个脚本：升级脚本、回滚脚本。
- 有一个配置项来设置数据库与应用版本对应关系。

在很多项目中，多个程序共用一套数据库存储。虽然这种方式并不推荐，最好是让程序直接交互，但是这种情况却是常见的。这种环境下对数据库变更，就需要对程序做完全的集成测试，确保数据库变更对相关影响到的程序都能测试到。同时对**哪个应用使用了数据库哪个对象**做登记也是可以的。

## 数据库回滚和无停机发布

生产环境部署有两个需求会成为数据库回滚的约束。（P268）

一、回滚时需要保留本次升级后产生的数据。

二、根据签订的SLA，要保持应用程序的可用状态。

**1.保留数据的回滚**
回滚脚本要满足以下条件：

- 包括模式修改，即不丢失任何数据。
- 只删除新版本使用的那些数据，即使这些数据丢失了也没什么大问题。

对于以下情况，简单的运行回滚脚本是不行的

- 涉及从临时表中将数据导回来。
- 删除那些旧版本系统无法接受的数据。

一种方法是将那些不想丢失的数据库事务缓存，一旦应用程序被成功地重新部署，这些事件就可以重新播放一遍。
第二种方法是使用蓝绿部署，发布时对生产数据库（蓝环境）做一个备份，将备份放在绿环境中应用，迁移数据，将用户切换到绿环境中。回滚时，将用户切回蓝环境，再把绿环境的数据库上发生的新事务回收，在下一次更新之前重新应用这些事务到蓝数据库上。（P269）

**2.应用程序部署与数据库迁移解耦**

第三种方法是将应用程序部署过程与数据迁移过程解耦，分别执行，这种可用于管理热部署。
开发应用程序升级的中间版本，它既与数据库上个版本兼容，也与数据库下个版本兼容。

应用程序部署与数据库迁移解耦图

<img src='./pic/ContinuousDelivery/应用程序部署与数据库迁移解耦.jpg'/>

## 测试数据的管理

**1.为单元测试进行数据库模拟**
单元测试不使用真正的数据库，通常它会使用测试替身对象来取代与数据库打交道的服务。如果做不到的话（P271）：

- 用测试替身对象来替代那些访问数据库的代码，通常使用repository模式。
- 使用假的数据库，如H2/SQLite/JavaDB。单元测试运行在一个内存数据库上，让验收测试运行在平时使用的磁盘的数据库上。

**2.管理测试与数据之间的耦合**
以下三种方法可以用来做测试设计，便于管理好数据的状态（P272）：

- **测试的独立性**，合理组织测试，让每个测试的数据只对该测试可见。
- **适应性测试**，运行时先对数据环境进行检查，用检查的数据作为数据基础进行测试。
- **测试的顺序性**，按某种已知的序列运行，每次测试输入依赖于前一个输出。

保持测试的独立性最简单的方法是确保在测试结束时，总是把数据库中的数据状态恢复到测试之前。
对于支持事务的数据库来说，测试开始时创建一个事务，在事务内执行所需的数据库操作与交互，测试结束后，将该事务进行回滚。
不建议创建一个连贯的“故事”进行顺序执行，这个有序的测试无法真正地代表测试的目的和内容。

## 数据管理和部署流水线

- 提交阶段的测试数据，避免复杂的数据准备。
- 验收测试的数据，尽可能减少测试对大型复杂数据结构的依赖。测试专属数据、测试引用数据、应用程序引用数据。
- 容量测试的数据，为测试提供足够的输入数据，准备适当的引用数据支持测试中的用例。
- 其他测试阶段的数据，推荐利用生产数据的一个子集或者运行一些自动化验收测试或者容量测试之后产生的数据库，为其他测试阶段提供数据。



# 第十三章：组件和依赖管理

持续交付让应用程序处于随时可发布的状态。在大型重构或添加复杂功能时，要继续保持应用的可发布状态，需要对大型应用组件化。
**组件**是指应用程序中的一个规模相当大的代码结构，它具有一套定义良好的API，而且可以被另一种实现方式代替。一个基于组件的软件系统，通常其代码库被分成多个相互分离的部分，每个部分通过有限的定义良好的接口提供一些服务与其他组件进行有限的交互。有人把组件称为模块。
基于组件的设计是一种良好的架构，具有松耦合性。

## 保持应用程序可发布

团队不断地增加新特性，可以给每次新特性创建新的分支，当新特性完成后，再将它合并到主分支。这将会导致合并周期变长，无法做到持续集成，这种方法不是最好的。**提倡每个人都应该提交到主干**。如何保证主干一直保持可发布状态。有以下四种策略（P282）：

- 将新功能隐藏起来，直到它完成为止。一种方法是把新功能直接放进主干，但对用户不可见，比如通过单独的URL来访问，通过Web服务器配置不允许访问其入口；另一种方法是通过配置项开关来管理。把功能半成品与系统其他部分一同发布是一个好实践。
- 将所有的变更都变成一系列的增量小修改，而每次小修改都是可发布的。首先需要用各种方式将一个需求分解成较小的任务，然后将这些任务再划分成更小的增量修改。
- 使用通过抽象来模拟分支的方式对代码库进行大范围的变更。在要修改的那部分代码上创建一个抽象层，然后在当前实现方法存在的同时，开发一种新的实现方式，当完成时再把原始的实现和抽象层删除。
- 使用组件，根据不同部分修改的频率对应用程序解耦。

## 依赖

库是团队除了选择权以外，没有控制权的软件包，它们很少更新。组件是应用程序所依赖的代码块，它一般由团队自己开发的，更新频繁。
 构建时的依赖会与运行时依赖不同，管理依赖遇到问题。

- 依赖地狱。应用程序的依赖版本与实际部署的版本不一致。
- 库管理。一种方法是将库文件提交到代码版本控制库中，但时间久了后会导致版本库变大且乱，同时库文件的状态难以管理。另一种方法是使用显示声明的库管理工具，如Maven。

## 组件

只有一个系统达到一定的复杂度时，才会考虑将它分成多个组件。组件的目的是为了提交团队的效率（P289）。

- 它将问题分成更小更达意的代码块。
- 组件常常表示出系统不同部分代码的变化率不同，且有不同的生命周期。
- 将代码划分，也便于分析系统的职责描述和维护，并且提交了对代码的理解。
- 提供了额外的自由度来优化构建和部署过程。

当我们遇到以下情况时，可以考虑将组件代码从代码库中独立出来（P290）。

- 代码库的一部分需要独立部署。
- 打算将系统分成一个内核和一系列组件，以便用另一种实现代替当前系统的某部分或者支持用户自扩展。
- 组件为其他系统提供了一个接口（如API接口）。
- 代码的编译和链接时间太长。
- 在开发环境中打开项目时间太长。
- 对一个团队来说，代码库太大。

大多数情况下，我们建议整个应用程序使用一个构建流水线，每次提交修改时，就应该构建并测试整个应用。只有当效率太低而无法忍受时，才使用并行流水线方式。

## 二进制包管理

使用制品库来管理二进制包，如Artifactory，Nexus。制品库不应该包含那些无法重现的产物，即便删除整个制品库，也可以方便地将二进制包恢复出来，一般通过重新构建对应的代码。
最简单的制品库是磁盘上的一个目录，最重要的是它应该将一个二进制文件关联到版本控制库中生成该文件的某个源码版本对应上。
**部署流水线与制品库相结合**（P304）

- 编译阶段会创建需要放到制品库的二进制文件。
- 单元测试和验收测试阶段会从制品库中取出这些二进制文件，将生成的测试报告放在制品库中。
- 用户验收测试阶段将二进制文件部署到UAT环境，用于手工测试。
- 发布阶段从制品库中取出二进制文件，将它部署到生产环境。



# 第十四章：版本控制进阶

版本控制用来维护应用程序每次修改的完整历史，包括源代码、文档、数据库定义、构建脚本和测试等。团队可以一起工作应用程序的不同部分，并且同事维护系统记录。一旦团队人数超过一定数量，就需要规划版本控制库的使用，让开发更加高效。

## 分支与合并

分支，即为选择的基线创建一个副本，该副本与原基线相互独立，开发者能在两个工作流上同时开发。（P315）

- 物理上：系统物理配置而分支，即为文件、组件和子系统而分支。
- 功能上：系统功能配置而分支，即为特性、逻辑修改、缺陷修复和功能增加，以及其他可交付的功能而分支。
- 环境上：系统运行环境而分支，即由构建平台和运行时平台的不同而分支
- 组织上：团队的工作量而分支，即为活动/任务、子项目、角色和群组而分支
- 流程上：团队的工作行为而分支，支持不同规章政策、流程和状态而分支。

在开发中，经常会遇到分支合并的情况，除非那些为了发布或者技术预研而创建的分支。两次合并时间间隔越长，每个分支上工作的人越多，合并发生冲突的可能性就越大。（P316）以下两种方法来减小冲突：

- 创建更多的分支来减少在每个分支上的修改。这只是将痛苦延后而已。
- 很谨慎地创建分支，可能每个发布才创建一个分支。为了尽量减少合并的痛苦就经常做合并。
   一个强烈推荐的分支策略是：只为发布创建长期的分支。这种模式下，新开发的代码总是被提交到主干上，只有在发布分支上修改缺陷时才需要合并，而这具合并是从分支合并回主干。只有非常严重的缺陷修复才会从主干合并到发布分支上。

## 分布式版本控制系统DVCS

分布式版本控制系统就是每个使用者本地都有一个完整的代码仓库（P319）。它有了很多新特性：

- 在几秒内就能开始使用分布式版本控制系统。
- 可以单独从别人那里拿到他们的最新更新，不需要提交到中央代码库。
- 可以将自己修改推送到一组人的代码库中，而不需要他们每个人来取你的修改。
- 补丁可以通过网络用户更高效地传播。
- 没有网络的时候，也可以对修改的代码版本控制。
- 可以频繁地提交未完成的功能到本地代码库，而不影响其他人。
- 将修改发送给其他人之前，可以很容易地在本地对这些提交进行修改，重排它们的顺序或者将多次提交打包成一个，这个叫‘rebasing'。
- 很容易用本地代码库来尝试各种解决方案或想法。
- 能在本地把多次提交打包。
- 在本地建立和同步多个代理库很容易，有更高的可用性。
- 全量代码有很多份副本，有更好的容错性。

## 主干开发

开发人员总是提交代码到主干，而使用很少使用分支（P329）。这有以下三个好处：

1. 确保所有代码被持续集成。
2. 确保开发人员及时获得他人的修改。
3. 避免项目后期的“合并地狱”和“集成地狱”。

开发人员在主干上工作，每天至少提交一次代码。当需要做复杂的修改时，修改会被分成一系列小的增量步骤有计划地实现，而每个步骤都会通过测试且不会破坏已有的功能。
主干开发并不排斥分支，只有当不需要合并回主干时，才创建分支。如发布分支，技术预研分支。
如果开发人员很多，且有多个版本发布的大型团队，软件需要良好的组件化、增量式开发和特性隐藏。要做的是持续频繁地向主干分支提交代码，每天至少一次提交。

## 按发布创建分支

在某个版本即将发布之前，创建发布分支。该分支一旦创建，该发布版本的测试和验证全部在该分支上进行，而最新的开发工作仍然在旧的主干分支上进行。发布分支上只做严重缺陷的修复（P332）。遵循如下规则：

1. 一直在主干上开发新功能。
2. 当待分布版本的所有功能完成，且希望继续开发新功能时才创建一个分支。
3. 在分支上只允许提交修复严重缺陷的代码，且这些修改必须立即合并到主干。
4. 执行实际的发布时，这个分支可以选择性地打个标签。

不要在已有的发布分支上再创建更多的分支，所有后续分支都应该从主干上创建。
一旦发布频率达到一定的频率（比如一周一次），就没必要创建分支了，在这种情况下，发布一个新版本要比在已发布的分支上打补丁更容易，成本更低。而且部署流水线机制可能为你保留了一份记录，包括发布的软件在版本控制库中对应的修订版本号。

## 按功能特性分支

为了让开发团队更容易在“特性”层次上并行工作，并保持主干为可发布状态，这时使用特性分支。（P333）使用特性分支，需要遵循以下规则：

1. 每天都要把主干上的所有变更合并到每个分支上。
2. 每个特性分支都应该是短生命周期的，理想情况只有几天。
3. 活跃分支的数量随时都应该少于或等于开在开发当中的用户故事的数量。只有在已经把开发的用户故事合并回主干，才允许创建新的特性分支。
4. 在合并回主干之前，该用户故事应该已经由测试人员验收通过。
5. 重构必须即时合并，从而将合并冲突最小化。
6. 技术负责人的一部分职责就是保证主干的可发布状态。

## 按团队分支

团队分支模式的工作流：
多个开发人员同时工作在多个工作流上，还要保证主干随时可发布状态。（P336）

1. 创建多个小团队，每个团队自己有对应的分支。
2. 一旦某个特性或用户故事完成，让该分支稳定下来，合并到主干。
3. 每天都将主干上的变更合并到每个分支上。
4. 对于每个分支，每次提交代码都要运行单元测试和验收测试。
5. 每次分支合并回主干时，主干上也要运行所有的测试，包括集成测试。

在有几个比较小而且相对独立的团队，同时各团队负责该软件系统中功能相对独立的情况下，该模式才有效。
从持续集成的角度说，该策略有一些缺点，根本问题是该模式下的工作单元是一个分支，而不是一次特定的修改。

# 第十五章：持续交付管理

实现持续交付不仅仅是搭建一些工具，做一些自动化的工作，它依赖于交付过程中的每个人的协作。通过持续交付实践，可以快速且可靠地交付新版本。

## 配置与发布管理成熟模型

成熟度模型图

<img src='./pic/ContinuousDelivery/成熟度模型.jpg'/>

这个模型的最终目标：

- 缩短生产周期
- 减少缺陷
- 提高软件交付生命周期的可预测性
- 规范合规
- 有效发现和管理软件交付相关风险
- 交付更少缺陷的软件，降低成本

模型指导组织推进持续交付变革，使用戴明环，即计划——执行——检查——处理。（P343）

1. 使用模型来分析所在部门的配置与发布管理模式。
2. 选择一个领域集中发力，该领域是你的薄弱环节，痛点所在。
3. 实施变革。先创建一个实施计划，选择真正感到痛苦的那部分人。
4. 一旦发生了变化，使用之前创建的验收条件来衡量这些变化是否达到了预期效果。组织所有相关人员召开回顾会议，找出改进点及潜在改进领域。
5. 重复上述步骤，积累知识，增量改进，推广到整个部门。

## 项目生命周期

团队的组建与磨合常常有以下五个阶段：创建期、风暴期、规范期、运转期、调整重组期。软件也有五个阶段：识别阶段、启动阶段、初始阶段、开发部署阶段、运维阶段。

- 识别阶段：业务分析、业务部门决定策略目标并识别需要做的计划任务。
- 启动阶段：需求收集和分析，规范项目范围和计划。输出有，商务分析报告、概括性的功能与非功能需求列表、发布计划、测试策略、发布策略、架构评估报告 、风险和问题列表、开发生命周期描述、执行上述内容计划描述。包括足以启用项目的细节和最多几个月需交付目标，最合理周期为3个月。
- 初始阶段：一到二周，确保软硬件到位；确保网络、白板、笔纸、打印机、食品等到位；建立好版本控制库；建立一个基本的持续集成环境；角色、职责、工作时间、会议时间上达成一致；为第一周做准备，目标上达成一致；创建简单的测试环境与测试数据；更详细研究预定的系统设计 ；调研识别和缓解分析、开发、测试风险；开发用户故事与需求的待办列表；创建项目结构及构建脚本和一些测试，以验证持续集成环境正常工作。
- 开发部署阶段：迭代开发是最基本要求。软件应该一直处于可工作状态；每个迭代都能将软件部署到一个类生产环境中向用户演示；迭代长度不超过两周。
- 运维阶段：项目开发部署阶段结束后，一般项目还会继续开发下去，此过程与开发部署阶段差不多。

## 风险管理流程

风险管理时间轴：

- 启动阶段结束时：验证发布策略在关于“创建发布策略”一节（10.2）节讨论过的方面都考虑到了；做好初始阶段的计划。
- 初始阶段结束时：确保团队已经准备好开始开发软件了，持续集成环境正常工作，并且有一个类生产环境用于产品代码的部署。
- 开发部署风险的缓解：识别、跟踪和管理风险，及时调整。查看部署计划，每次演示后做简单的回顾会议，每日立会作为风险识别的一部分。

## 常见交付问题和原因

1. 构建某个版本花很长时间，而且经常失败
   可能原因：部署过程非自动化；没有足够的硬件；硬件和操作系统配置没有正确管理 ；部署过程依赖于团队无法掌控的系统；没有足够多的人员理解构建和部署过程；测试、开发、分析和运营人员没有充分协作；开发人员没有遵守纪律，通过小步增量的方式的修改保证应用程序一直处于可工作状态。
2. 缺陷数量持续增加，产品质量下降
   可能原因：开发期间，测试与开发没有协作；用户故事在没有全面测试，被测试人员验收，并在类生产环境下给用户演示的情况下标记为“完成”；开发与测试在自动化测试套件开发方面缺少经验；团队不了解哪种类型的测试有效；没有足够的测试覆盖率；系统原来就是一个不可靠的原型。
3. 集成周期长，迭代速度慢
   可能原因：自动化测试运行时间太长；提交阶段运行时间太长；自动化测试有间歇性失败，还是误报；没人得到许可就回滚别人的提交；没有足够多的人理解持续集成过程。
4. 环境不一致，导致生产故障
   可能原因：UAT和生产环境有差异；没有对生产环境或试运行环境的变更管理流程；在运营、数据管理团队和交付团队间协作不畅；生产环境和试运行环境中的缺陷事件的监管不够有效；应用程序中的指南和日志不充分；应用程序非功能需求测试不充分。

